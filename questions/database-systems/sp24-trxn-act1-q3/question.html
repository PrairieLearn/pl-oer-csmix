
<pl-question-panel>

    <p>
        Consider the schedule followed by transactions operating on database objects {{params.relation}}. Determine the feasibility of the schedule by placing locks in the schedule, while respecting each transaction's isolation level. Note: locks must be released whenever possible (while respecting the isolation level) and each transaction must commit by the end of its last action.
    </p>
    
    <code>{{params.schedule}}</code><br><br>

    Determine whether the given schedule is possible under the following isolation levels:<br>
    <ul>
        {{{params.isolevels}}}
    </ul>
    
    Note: Ri(A) means reading A for Transaction i. Wi(A) means writing A for Transaction i.<br><br>
    
    Solution Format:
    <ul class="list-group list-group-flush">
        <li class="list-group-item">For example, your solution for the schedule should be formatted as follows: <code>S1(A);R1(A);REL1(A)</code></li>
        <li class="list-group-item">Use <code>Si(A)</code> to indicate a shared lock for A in Transaction i. </li>
        <li class="list-group-item">Use <code>Xi(A)</code> to indicate an exclusive lock for A in Transaction i. </li>
        <li class="list-group-item">Use RELi(A,B) to indicate the release of the lock(s) for (A,B) in Transaction i. </li>
        <li class="list-group-item">If a request for a lock is denied, add <code>DENIEDi(A)</code> after you try to lock the attribute, where i is the transaction that was denied, and A is the attribute it was trying to lock. At this point, stop writing the rest of the schedule.</li>
        <li class="list-group-item">When a transaction runs its final read or write, assume it commits, and is <b>finished</b>. Finished transactions should always release any locks they have.</li>
        <li class="list-group-item">Separate all executions with <code>;</code>.</li>
    </ul>
  
</pl-question-panel>
<pl-string-input size=80 answers-name="schedule"></pl-string-input>
